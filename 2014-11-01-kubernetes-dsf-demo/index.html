<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>2014 11 01 kubernetes dsf demo - CodingBird</title>
  

  
  <link href='https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700' rel='stylesheet' type='text/css'>

  <link rel="stylesheet" href="../css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../css/theme_extra.css" type="text/css" />
  <link rel="stylesheet" href="../css/highlight.css">

  <script src="//cdnjs.cloudflare.com/ajax/libs/jquery/2.1.1/jquery.min.js"></script>
  <script src="//cdnjs.cloudflare.com/ajax/libs/modernizr/2.8.3/modernizr.min.js"></script>
  <script type="text/javascript" src="../js/highlight.pack.js"></script>
  <script src="../js/theme.js"></script>

  <style>
    body {font-size: 90%;}
    pre, code {font-size: 100%;}
    h3, h4, h5, h6 {color: #2980b9; font-weight: 300}
  </style> 
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
      <div class="wy-side-nav-search">
        <a href=".." class="icon icon-home"> CodingBird</a>
        
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
      <ul class="current">
    
        
            <li class="toctree-l1 ">
                <a class="" href="../2014-10-30-dse-docker-demo">2014 10 30 dse docker demo</a>
            </li>
        

    
        
            <li class="toctree-l1 current">
                <a class="current" href=".">2014 11 01 kubernetes dsf demo</a>
            </li>
        

    
        
            <li class="toctree-l1 ">
                <a class="" href="../2014-11-05-Kubernetes-REST-API">2014 11 05 Kubernetes REST API</a>
            </li>
        

    
        
            <li class="toctree-l1 ">
                <a class="" href="../2014-11-12-Demystifying-Flynn">2014 11 12 Demystifying Flynn</a>
            </li>
        

    
        
            <li class="toctree-l1 ">
                <a class="" href="../2014-11-22-jflynn-tryout">2014 11 22 jflynn tryout</a>
            </li>
        

    
        
            <li class="toctree-l1 ">
                <a class="" href="../2015-01-05-Docker-Era-Is-Coming">2015 01 05 Docker Era Is Coming</a>
            </li>
        

    
        
            <li class="toctree-l1 ">
                <a class="" href="../2015-01-26-Lhotse-Dockerized">2015 01 26 Lhotse Dockerized</a>
            </li>
        

    
</ul>

      </div>
      &nbsp;
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="icon icon-reorder"></i>
        <a href=".."></a>
      </nav>

      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="..">Docs</a> &raquo;</li>
    <li>2014 11 01 kubernetes dsf demo</li>
      <li class="wy-breadcrumbs-aside">
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main">
            <div class="section">
              <hr />
<p>layout: post
title: 【分布式服务框架DSF演进系列-2】服务引擎Docker容器化的实践与探索
published: true</p>
<hr />
<p>本系列前文《基于Docker容器和资源调度的探索及平台规划》已经对分布式服务框架DSF的演进动机及思路做了详细地讨论，本文旨在分享我们在服务引擎容器化方面的实践，并以Google的Kubernetes系统为基础演示资源调度与自动部署的方案。</p>
<h3 id="_1">什么是服务引擎</h3>
<p>DSF中的核心系统是服务引擎(Data Service Engine，简称DSE)，是一个服务运行容器，提供统一化的通讯协议与调用接口，支持RPC和Servlet协议。简单来说，DSE降低了分布式服务的开发成本，使得开发人员只专注于业务逻辑，无需考虑通讯协议、容灾、负载均衡等通用逻辑。(详细介绍参考wiki链接http://dsfwiki.oa.com/DSF/Wiki.jsp?page=DSE%20Intro)</p>
<h3 id="_2">服务引擎的容器化改造</h3>
<p>前文提到服务引擎可以大大降低开发成本，但是也面临一些限制，比如服务开发语言只支持Java、服务有第三方软件依赖需要手工部署等等。为了解决这些问题，我们决定将服务引擎容器化，使得服务可以与其运行环境(语言环境、软件环境等)一起打包部署。</p>
<p>天下没有免费的午餐，要把原本跑在物理机或虚拟机上的应用程序迁移到docker容器里，都需要做一定的改造，<a href="http://12factor.net/">"The Twelve Factors"</a>对此做了很系统地总结。下面从网络配置、启动脚本、引擎日志及心跳上报四个方面记录一下我们对DSE所做的改造：</p>
<p><strong>网络配置</strong></p>
<p>DSE启动后需要打开一个NIO服务器来接受调用请求，其监听的IP和port是通过一个server.conf文件来配置。假如DSE部署在一台IP为10.136.4.88的机器上，需要做如下配置：</p>
<pre><code>#DSE Main TCP Host
taserver.host=10.136.4.88
#DSE Main TCP Port
taserver.port=19800
</code></pre>
<p>然而，假如DSE运行在docker容器里，这样的配置是无法生效的，因为容器看不到宿主机的网络接口。容器实际上被分配的是一个名为docker0的虚拟网络接口，其IP是从宿主机上随机选择的，通过桥接方式与宿主机互通。因此，方便起见直接将IP配置为0.0.0.0，port配置为19800。这个配置可以写死在文件中保持不变，不必因部署机器的改变而修改：</p>
<pre><code>#DSE Main TCP Host
taserver.host=0.0.0.0
#DSE Main TCP Port
taserver.port=19800
</code></pre>
<p><strong>启动脚本</strong></p>
<p>DSE的启动脚本是以后台程序来启动的，这里需要改成前台程序，因为如果没有前台程序，docker容器会立即退出。</p>
<p><strong>引擎日志</strong></p>
<p>DSE的系统日志是通过log4j写入特定文件中，这里需要改成写入stdout，因为docker容器默认只会保留stdout中的日志，其他日志文件一旦容器停止将会丢失。P.S：当然，另一种常见的做法是将日志所在的文件夹映射到宿主机上。</p>
<p><strong>心跳上报</strong></p>
<p>DSF的另一个核心系统是软负载(详细介绍可以参考wiki链接http://dsfwiki.oa.com/DSF/Wiki.jsp?page=RouterCenter%20Intro )，提供服务发现、路由寻址功能，它要求DSE定期上报心跳，汇报托管在DSE之上的服务的地址信息及其运行状态。原本心跳上报模块是通过从server.conf文件中读取到的IP和port来拼接服务地址的，但如前文所述，server.conf文件中的IP已经修改成了0.0.0.0，显然不能上报这样的IP。</p>
<p>由于目前还没有很好的方式在docker容器里获取其宿主机的IP，我们采取的临时方案是：在docker启动容器时，通过环境变量将宿主机的IP及该容器映射的宿主机port注入容器。</p>
<h3 id="docker">服务引擎的Docker镜像制作</h3>
<p>在对DSE进行简单的改造后，就可以来制作docker镜像了，首先是编写Dockerfile，内容如下：</p>
<pre><code>### tegdsf/centos在base centos镜像之上安装了jdk, maven及svn
FROM tegdsf/centos
### 通过svn获取服务引擎代码
RUN svn checkout http://tc-svn.tencent.com/doss/doss_openapi_rep/openapi_proj/branches/commons/DSE/docker_1.0 /root/dse-docker
### 通过maven编译打包
RUN cd /root/dse-docker; mvn package
### 将部署包拷贝到特定文件夹
RUN rm /root/dse-docker/release/*.tar
RUN mkdir /root/dse-latest
RUN mv /root/dse-docker/release/dse-*/* /root/dse-latest/
### 对启动/停止脚本设置可执行权限
RUN chmod +x /root/dse-*/bin/start.sh
RUN chmod +x /root/dse-*/bin/kill.sh
RUN rm -r /root/dse-docker
RUN rm -r /tmp/mavenRepository
### 服务引擎默认监听19800端口
EXPOSE 19800
### start.sh是服务引擎的启动脚本
ENTRYPOINT /root/dse-latest/bin/start.sh
</code></pre>
<p>然后通过docker build命令来构建：</p>
<pre><code>docker build -t tegdsf/dse .
</code></pre>
<p>最后，可以对构建好的镜像做简单的测试：</p>
<pre><code># docker run -d -p 127.0.0.1:19800:19800 tegdsf/dse
4c55f2081eac
# curl localhost:19800/internal/heartbeat.jsp
&lt;html&gt;
Heartbeat Page.
&lt;/html&gt;
</code></pre>
<p>测试通过后，我们可以把镜像push到远程仓库，这里推荐数平gaia团队搭建的私有仓库docker.oa.com:8080(详细介绍参考链接http://km.oa.com/group/docker/articles/show/205373 )。</p>
<h3 id="_3">自动部署</h3>
<p>本系列前文《基于Docker容器和资源调度的探索及平台规划》详细描述了我们结合Gaia系统来做资源调度和自动部署的方案，这里分享一下另一种基于Kubernetes的方案。Kubernetes是Google开源的容器集群管理系统。它构建于docker技术之上，为容器化的应用提供资源调度、部署运行、服务发现、扩容缩容等整一套功能，本质上可看作是基于容器技术的mini-PaaS平台。具体的原理介绍和实践操作可以参考文章http://km.oa.com/group/597/articles/show/205884。</p>
<p>首先，我们搭建了由两台机器组成的Kubernetes集群，一台机器既做master也做slave，通过命令行工具查看slave(称为minion)如下：</p>
<pre><code>$ kubecfg -h 10.6.207.17 list /minions
Minion identifier
----------
10.6.207.17
10.6.207.228
</code></pre>
<p>接下来，我们通过Kubernetes的replicationController对象来部署多个服务实例，编写json描述文件如下：</p>
<pre><code>{
  "id": "dse-demo",
  "apiVersion": "v1beta1",
  "kind": "ReplicationController",
  "desiredState": {
    "replicas": 2,
    "replicaSelector": {"name": "dse-demo"},
    "podTemplate": {
      "desiredState": {
         "manifest": {
           "version": "v1beta1",
           "id": "dse-demo",
           "containers": [{
             "name": "dse-demo",
             "image": "tegdsf/dse",
              "imagePullPolicy": "PullIfNotPresent",
             "ports": [{"containerPort": 19800, "hostPort": 19800}]
           }]
         }
       },
       "labels": {"name": "dse-demo"}
      }},
  "labels": {"name": "dse-demo"}
}
</code></pre>
<p>可以看到，通过"replicas"字段可以指定服务实例的个数。最后，用命令行工具提交描述文件：</p>
<pre><code>$ kubecfg -h 10.6.207.17 -c dseController.json create /replicationControllers
ID                  Image(s)            Selector            Replicas
----------          ----------          ----------          ----------
dse-demo            tegdsf/dse          name=dse-demo       2
</code></pre>
<p>可以看到2个实例已经部署成功，并处于"Running"状态：</p>
<pre><code>$ kubecfg -h 10.6.207.17 list /pods
ID                                     Image(s)            Host                Labels                                         Status
----------                             ----------          ----------          ----------                                     ----------
9a64445a-6557-11e4-b410-001f290cf88c   tegdsf/dse          10.6.207.228/       name=dse-demo,replicationController=dse-demo   Running
9a646fb6-6557-11e4-b410-001f290cf88c   tegdsf/dse          10.6.207.17/        name=dse-demo,replicationController=dse-demo   Running
</code></pre>
<p>通过docker ps也可以看到被Kubernetes启动的容器：</p>
<pre><code class="bash">
$ docker ps
CONTAINER ID        IMAGE                     COMMAND                CREATED             STATUS              PORTS                      NAMES
37fab78246e0        tegdsf/dse:latest         "/bin/sh -c /root/ds   3 minutes ago       Up 3 minutes                                   k8s_dse-demo.4314872b_9a646fb6-6557-11e4-b410-001f290cf88c.default.etcd_1415238765_7e8d8da7   
8f91f09d6d4e        kubernetes-pause:latest   "/pause"               3 minutes ago       Up 3 minutes        0.0.0.0:19800->19800/tcp   k8s_net.40d9846a_9a646fb6-6557-11e4-b410-001f290cf88c.default.etcd_1415238765_751ba7fd       
</code></pre>

<h3 id="_4">后续工作</h3>
<p>经过前文所述的工作，我们已经把服务框架DSF的服务引擎DSE容器化，并试验了自动部署的方案。但是，真正要应用于生产环境，还有不少工作要做，这里提两点方向，会在后面的系列文章中分享我们的探索与实践。</p>
<h4 id="_5">服务发现</h4>
<p>当我们把服务通过Gaia或Kubernetes这样的系统来做调度和部署时，服务真正的运行机器是动态可变的，面临地问题是服务消费者如何及时地发现服务。Kubernetes基于代理的思路包装了service的概念，但主要是用于系统内部各服务之间相互发现，没有解决外部消费者的发现问题。接下来，我们考虑将服务框架的软负载与Kubernetes结合，来为外部客户提供服务路由功能。</p>
<h4 id="_6">日志收集</h4>
<p>Docker容器的日志收集这块，业界已经有很多人在探索，目标都是将传统成熟的日志收集方案(比如，Logstash + ElasticSearch +Kibana)平滑地迁移到基于容器的平台系统。接下来，我们也将探索各种不同的方案，筛选出最合适自己的。</p>

            </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="../2014-11-05-Kubernetes-REST-API" class="btn btn-neutral float-right" title="2014 11 05 Kubernetes REST API"/>Next <span class="icon icon-circle-arrow-right"></span></a>
      
      
        <a href="../2014-10-30-dse-docker-demo" class="btn btn-neutral" title="2014 10 30 dse docker demo"><span class="icon icon-circle-arrow-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
    <!-- Copyright etc -->
    </p>
  </div>

  Built with <a href="http://www.mkdocs.org">MkDocs</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
	  
        </div>
      </div>

    </section>

  </div>

<div class="rst-versions" role="note" style="cursor: pointer">
    <span class="rst-current-version" data-toggle="rst-current-version">
        
      <span><a href="../2014-10-30-dse-docker-demo" style="color: #fcfcfc;">&laquo; Previous</a></span>
      <span style="margin-left: 15px"><a href="../2014-11-05-Kubernetes-REST-API" style="color: #fcfcfc">Next &raquo;</a></span>
    </span>
</div>
</body>
</html>